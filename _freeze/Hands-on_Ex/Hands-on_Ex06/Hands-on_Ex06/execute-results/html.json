{
  "hash": "4e0b175326cb684bd50d497bdb72761d",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Hands-on exercise06\"\nauthor: \"Yuheng Liang\"\nformat: html\neditor: visual\ndate: \"September 16, 2024\"\ndate-modified: \"September 16,2024\"\nexecute: \n  eval: true\n  echo: true\n  freeze: true\n---\n\n\n# Hands_on exercise06 Measures of Spatial Autocorrelation\n## 1.0 Tools and data\n### 1.1 setting the tools\nspdep: will be used to compute spatial weights, global and local spatial autocorrelation statistics.\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(sf,spdep,tmap,tidyverse,ggplot2)\n```\n:::\n\n### 1.2  Importing the data\nimporting the shapefile into environment\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan <- st_read(dsn = \"data/geospatial\", layer = \"hunan\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `hunan' from data source \n  `/Users/liangyuhang/Downloads/Maaaaaaaaaark/IS415_g/Hands-on_Ex/Hands-on_Ex06/data/geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 88 features and 7 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\n```\n\n\n:::\n:::\n\nimporting csv file\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan2012 <- read_csv(\"data/aspatial/hunan_2012.csv\")\n```\n:::\n\nperforming relational join\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan <-left_join(hunan,hunan2012)%>%\n  select(1:4,7,15)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_rds(hunan,\"data/rds/hunan.rds\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan<- read_rds(\"data/rds/hunan.rds\")\n```\n:::\n\n### 1.3 Visualising Region Development Indicator\npreapre a basemap and a choropleth map showing the distribution of GDPPC 2012 by using qtm() of tmaps package.\n#### 1.3.1 Equal interval classification\n\n::: {.cell}\n\n```{.r .cell-code}\nequal <- tm_shape(hunan)+\n  tm_fill(\"GDPPC\",\n          n=5,\n          style =\"equal\" )+\n  tm_borders(alpha = 0.5)+\n  tm_layout(main.title = \"Equal interval classification\")\n```\n:::\n\n\n#### 1.3.2 Equal quantitle classification\n\n::: {.cell}\n\n```{.r .cell-code}\nquantile <- tm_shape(hunan)+\n  tm_fill(\"GDPPC\",\n          n=5,\n          style = \"quantile\")+\n  tm_borders(alpha = 0.5)+\n  tm_layout(main.title = \"Equal quantitle classification\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_arrange(equal,\n             quantile,\n             asp=1,\n             ncol = 2)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex06_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\n## 2.0 Global Measures of Spatial Autocorrelation\n### 2.1 computing contiguity spatial weights\nBefore we can compute the global spatial autocorrelation statistics, we need to construct a spatial weights of the area.\npoly2nb() of spdep packages is used to compute contiguity weigh for the study area.\nIf you do not specify this argument the default is set to TRUE, that is, if you donâ€™t specify queen = FALSE this function will return a list of first order neighbours using the Queen criteria.\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_q <- poly2nb(hunan, queen = TRUE)\nsummary(wm_q)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 11 \n 2  2 12 16 24 14 11  4  2  1 \n2 least connected regions:\n30 65 with 1 link\n1 most connected region:\n85 with 11 links\n```\n\n\n:::\n:::\n\nthe report show that there are 88 area units in hunan. The most connected area unit has 11 neightsbours. There are two units with only one neighbours.\n### 2.2 Row-standardised weights matrix\nassign weights to each neighboring polygon.\n\n::: {.cell}\n\n```{.r .cell-code}\nrswm_q <- nb2listw(wm_q, style = \"W\",zero.policy = TRUE)\nrswm_q\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: W \nWeights constants summary:\n   n   nn S0       S1       S2\nW 88 7744 88 37.86334 365.9147\n```\n\n\n:::\n:::\n\n* The input of nb2listw() must be an object of class nb. The syntax of the function has two major arguments,namely style and zero.poly\n* style can be W,B,C,U,minimax,S\n* If zero policy is set to true, weights vectors of zero length are inserted for regions without neighbour in the neighbours list.\n\n## 3.0 Global Measures of Spatial Autocorrelation: Moran's 1\nperform Moran's 1 statistics testing by using moran.test() of spdep\n### 3.1 MAron's 1 test\nMoran's statistical testing using moran.test() of spdep\n\n::: {.cell}\n\n```{.r .cell-code}\nmoran.test(hunan$GDPPC, \n           listw=rswm_q, \n           zero.policy = TRUE, \n           na.action=na.omit)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tMoran I test under randomisation\n\ndata:  hunan$GDPPC  \nweights: rswm_q    \n\nMoran I statistic standard deviate = 4.7351, p-value = 1.095e-06\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n      0.300749970      -0.011494253       0.004348351 \n```\n\n\n:::\n:::\n\nalternative hypothesis greater: This indicates that the alternative hypothesis is that the moran's 1 is greater than 0, meaning that postive spatial autocorrelation is expected\n\nThe result means that areas with high GDPPC tend to be clustered toghther, and areas with low GDPPC also tend to cluster together\n\n### 3.2 Computing Monte Carlo Moran's 1\nThe code chunk below performs permutation test for Moran's 1 statistic by using moran.mc() of spdep. A total of 1000 simulation will be performed.\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1234)\nbperm= moran.mc(hunan$GDPPC,\n                 listw = rswm_q,\n                 nsim = 999,\n                 zero.policy = TRUE,\n                 na.action = na.omit)\nbperm\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tMonte-Carlo simulation of Moran I\n\ndata:  hunan$GDPPC \nweights: rswm_q  \nnumber of simulations + 1: 1000 \n\nstatistic = 0.30075, observed rank = 1000, p-value = 0.001\nalternative hypothesis: greater\n```\n\n\n:::\n:::\n\nThe caculated Moran's value is 0.30075.The observed Moran's value has the highest rank among the 1000 simulated values, indicating it is the largest.The p-value is 0.001, which is very small.\n\nThe high Moran's value and the very low p-value indicate a significant positive spatial autocorrelation. This means that areas with high GDPPC tend to be clustered together, and areas with low GDPPC also tend to cluster together.\n\n### 3.3 Visualising Monte Carlo Moran's I\nplotting the distribution of the statistical values as a histogram by using the code chunk below.\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(bperm$res[1:999])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -0.01504572\n```\n\n\n:::\n\n```{.r .cell-code}\nvar(bperm$res[1:999])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.004371574\n```\n\n\n:::\n\n```{.r .cell-code}\nsummary(bperm$res[1:999])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n-0.18339 -0.06168 -0.02125 -0.01505  0.02611  0.27593 \n```\n\n\n:::\n:::\n\nIn the code chunk below hist() and abline() of R Graphics are used.\n\n::: {.cell}\n\n```{.r .cell-code}\nhist(bperm$res,\n     freq = TRUE,\n     breaks = 20,\n     xlab = \"Simulate Moran's I\")\nabline(v=0,col=\"red\")\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex06_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\nThe simulated Moran's value are centered around a particular value with a relatively symmetrical spread and the majority of simulated Moran's valued are centered around 0 which is expected under the null hypothesis of no spatial autocorrelation\n\n\n",
    "supporting": [
      "Hands-on_Ex06_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}